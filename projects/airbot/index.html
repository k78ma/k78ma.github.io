<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>AIRBOT | Kai Ma</title> <meta name="author" content="Kai Ma"> <meta name="description" content="Grasping and manipulation"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://k78ma.github.io/projects/airbot/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Kai </span>Ma</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/work/">work</a> </li> <li class="nav-item "> <a class="nav-link" href="/quartz/">notes</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">AIRBOT</h1> <p class="post-description">Grasping and manipulation</p> </header> <article> <p>As part of ELEC 4260 (Intelligent Robots and Embodied AI) at HKUST, I implemented various grasping methods for the <a href="https://airbots.online/" rel="external nofollow noopener" target="_blank">AIRBOT Play</a> robot arm:</p> <ul> <li>Basic grasping of circular objects</li> <li>Pose-based grasping with PoseCNN</li> <li>Direct grasp detection with GGCNN</li> </ul> <p>Videos:</p> <ul> <li><a href="https://www.youtube.com/embed/u2K_dRxwZqA?si=7dYKxJPM6IjhgiID" rel="external nofollow noopener" target="_blank">Basic circular object grasping</a></li> <li><a href="https://www.youtube.com/watch?v=_fcU-jTSsyM" rel="external nofollow noopener" target="_blank">Pose-based grasping with PoseCNN</a></li> <li><a href="https://www.youtube.com/watch?v=z-HZ2tYVTaU" rel="external nofollow noopener" target="_blank">Direct grasp detection with GGCNN</a></li> </ul> <h3 id="basic-grasping">Basic Grasping</h3> <div class="row mt-3"> <div class="col-12"> <figure> <iframe src="https://www.youtube.com/embed/u2K_dRxwZqA?si=7dYKxJPM6IjhgiID" class="img-fluid rounded z-depth-1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" width="auto" height="auto"></iframe> </figure> </div> </div> <p>This part of the project involved implementing simple functions for computing pre-grasp, grasp, and post-grasp poses, integrated into a simple grasping pipeline. A circle detector using OpenCV’s Hough Circle Transform was used to identify circluar objects within camera view, which were then converted to grasps. In terms of results, the robot was consistently able to grasp circular objects within its reach, with some occasional failures due to failing to detect a circular object.</p> <h3 id="pose-based-grasping-with-posecnn">Pose-Based Grasping with PoseCNN</h3> <div class="row mt-3"> <div class="col-12"> <figure> <iframe src="https://www.youtube.com/embed/_fcU-jTSsyM?si=OyNx4oE6wHQ6996n" class="img-fluid rounded z-depth-1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" width="auto" height="auto"></iframe> </figure> </div> </div> <p>To extend grasping to more complex everyday objects other with non-circular shapes, we trained a <a href="https://arxiv.org/abs/1711.00199" rel="external nofollow noopener" target="_blank">PoseCNN</a> network to estimate 6D object poses, which were refined and matched with grasp templates and executed. Each part of this pipeline is described below.</p> <h5 id="posecnn-model-implementation-and-training">PoseCNN Model Implementation and Training</h5> <p>The PoseCNN architecture was implemented following the original paper. It is built upon a VGG16 backbone for feature extraction, producing two feature maps. The network consists of three main branches:</p> <ul> <li>A segmentation branch for instance-level object detection using \(1 \times 1\) convolutions and upsampling operations, with cross-entropy loss for comparing predicted class probabilities to ground-truth segmentation labels.</li> <li>A translation branch estimating object centroids in 3D space, which is architecturally similar to the segmentation branch but for regression of centroid coordinates, using L1 loss as a metric.</li> <li>A rotation branch for quaternion-based orientation estimation using RoI pooling to extract features from deteced object regions. The rotation loss is only computed for ROIs that have sufficient overlap with ground-truth bounding boxes.</li> </ul> <p>The total loss is simply a sum of the three branches’ individual loss values, allowing all tasks to be learned simultaneously. The training loop in the provided boilerplate code used the Adam optimizer with a constant learning rate of 0.001, with the model being trained for 4 epochs.</p> <p>I faced several challenges during model training. First, training runs took a significant amount of time (usually 4-5 hours per epoch), which made it hard to iterate and debug. To deal with this, I added gradient scaling for mixed-precision training, casting the model’s operations to FP16 (half precision) where possible, which is faster and uses less memory.</p> <p>Furthermore, during preliminary training attempts, I noticed that the model rapidly improved at the beginning but did not improve much after a few thousand iterations. Thus, I decided to shorten the training process to 2 epochs, and a OneCycle learning rate scheduler with a lower learning base learning rate; this resulted in much lower loss (from total loss \(\approx\) 0.5 to \(\approx\) 0.2).</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/posecnn_losscurve.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="wheel odometry" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> PoseCNN training loss curves. </div> <p>Despite these attempts at improvement, the performance of my PoseCNN models were not ideal. I found that the model loss had a tendency to plateau quicly, settling around a total of 0.2; most of this was from the centermap/translation loss, which was usually around 0.13 - 0.15. While the rotation loss had high variance, it was generally very low.</p> <p>The issues with translation loss were clear during model evaluation and deployment. In an attempt to diagnose these issues, I tried to overfit the model to a single sample and a single scene. In these cases, the model produced perfect predictions (see left side of figure below), with translation loss of near zero. The large translation loss for the model trained on the whole dataset resulted in inaccurate reprojections as shown in the right side of the figure below..</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/result_comp.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="wheel odometry" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Inference results when overfit on a single scene (left) and trained on the whole dataset (right). </div> <p>This large difference in performance seems to indicate a lack of model capacity relative to the task; it might also be possible to achieve better results with a set of more ideal hyperparameters, learning rate scheduling, or optimizer. Another possible solution would be to add weighing to the the three loss terms. Given the short time frame for the project I was unable to find such a combination.</p> <h5 id="pose-refinement-and-deployment">Pose Refinement and Deployment</h5> <p>The aforementioned centroid prediction issues were significantly problematic when trying to use the predicted pose to achieve grasping on the real robot; see the left side of the figure below to see the large difference in translation between the predicted position of the object mesh and the actual point cloud. Thus, point cloud filtering and the iterative closest point (ICP) algorithm \cite{icp} were utilized to refine the predicted pose such that it matched the real pose.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/icp_grasp.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="wheel odometry" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Mispredicted object mesh (left). Object mesh aligned with point cloud and proposed grasp (right). </div> <p>Without filtering, I found that ICP would often converge to the wrong solutions, fitting the object mesh model to other parts of the scene, such as matching the flat surface of the bottle to the plane of the table; furthermore, due to the large size of the scene point clouds, ICP would take a long time to run.</p> <p>After basic cleaning of point clouds (removal of non-finite points), range-based filtering was applied to crop out points that were far away. Then, to filter out the large point cloud plane created by the table, RANSAC \cite{ransac} was used to find the dominant plane in the cloud, which was then removed. This combination of filtering resulted in almost all remaining points belonging to the object, improving the quality and speed of ICP clearly; see the right side of the figure below to see the refined pose compared to the actual objects.</p> <p>After this pose refinement, I was able to achieve successful grasping with select items. For this task, I set up the camera from a side angle instead of top-down in order to resemble the camera angles in the training set more closely. Despite this effort, this grasping pipeline was still extremely finicky; even in the successful grasp recorded in the video, the arm went through an extra twist to get to the target pose, which meant the target pose may have been upside down from the most optimal target pose. Another note is that I included the pre-grasp offset distance to avoid the gripper knocking over the object while approaching the pre-grasp pose.</p> <h3 id="learning-based-grasp-detection">Learning-Based Grasp Detection</h3> <div class="row mt-3"> <div class="col-12"> <figure> <iframe src="https://www.youtube.com/embed/z-HZ2tYVTaU?si=mWqEyoKZu-cI7_gh" class="img-fluid rounded z-depth-1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" width="auto" height="auto" title="YouTube video player"></iframe> </figure> </div> </div> <p>In this task, <a href="https://arxiv.org/abs/1804.05172" rel="external nofollow noopener" target="_blank">GGCNN</a> (Generative Grasping Convolutional Neural Network) was trained in order to directly detect grasps. I also implemented <a href="https://journals.sagepub.com/doi/10.1177/0278364919859066" rel="external nofollow noopener" target="_blank">GGCNN2</a>, presented in the journal version of the paper, which achieved slightly better results.</p> <h5 id="gg-cnngg-cnn2-model-implementation-and-training">GG-CNN/GG-CNN2 Model Implementation and Training</h5> <p>The GG-CNN model uses an encoder-decoder structure with 3 convolutional layers for encoding and 3 transposed convolutional layers for decoding. On the other hand, GG-CNN2 uses 4 convolutional layers for encoding, dilated convolutions to capture larger receptive fields, and bilinear upsampling instead of transposed convolutions. Both output three predictions: position, orientation (angle of gripper approach represented using cosine and sine components), and width.</p> <p>Training for these models was much more successful and straightforward than PoseCNN, achieving decent results in a short time. GG-CNN2 performed slightly better across the board and the two models took almost the same amount of time to train. Loss curves for GG-CNN and GG-CNN2 training are shown in the figures below.</p> <h5 id="gg-cnn2-model-deployment">GG-CNN2 Model Deployment</h5> <p>To maximize the chancces of success during deployment, I used the model with the highest IoU (GG-CNN2 model, epoch 33, with IoU = 0.77). I tried to emulate the camera angle of the images in the training set as closely as possible. It took a little bit of extra work to integrate the GraspDetectorNN class with the existig grasp_object script, as this was not provided in the boilerplate.</p> <p>I tried grasping various objects founda round the lab using the trained network, with varying success.</p> <ul> <li>Tape roll: 1/10. The model performed quite poorly in this case; this is likely because objects like tape rolls a hole in the middle were not in the training set (at the very least, I didn’t see any while skimming through the images).</li> <li>Squash ball: 6/10. This is likely due to the presence of other small round objects in the training data (some sort of fruit?). Since the object is spherical, it may also be more resistant to changes in position as it looks about the same from all angles.</li> <li>Remote control: 8/10. There were lots of examples of remote controls and similar objects in the training set, resulting in a high success rate. An example of a successful remote control grasp is shown in the video.</li> </ul> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/ggcnn2_loss.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="wheel odometry" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> IoU, training loss, and validation loss for GG-CNN (light blue) GG-CNN2 (dark blue). </div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/ggcnn2_trainloss.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="wheel odometry" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Training loss curves for each model output for GG-CNN (light blue) and GG-CNN2 (dark blue). </div> </article> </div> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>